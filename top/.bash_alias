# I hate system aliases...
unalias -a

alias "f"="finger"
alias "x"="xinit -- -ar1 200 -ar2 10 >& ~/.xinitout"
alias "rm"="rm -i"
alias "rmf"="/bin/rm -f"
alias "sl"="ls"
alias "l"="ls"
alias "s"="ls"
alias "cd"="pushd > /dev/null"
alias "back"="popd "
alias "mkae"="make"
alias "rootx"="xterm -T root@$(hostname) -n root@$(hostname) -bg grey20 -cr white -e su -"

function cleanup()
{
    /bin/rm -f *~ \
    .*~ \
    *.BAK \
    .*.BAK \
    *.CKP \
    .*.CKP \
     \#*\# \
    dead.letter \
        2>&1 > /dev/null
}

function xto()
{
    if [[ -z $1 ]]
    then
    	cat<<EOF
usage: xto <WHERE>
   sets DISPLAY to WHERE, where WHERE is:
      "back" for REMOTEHOST, if set
      "here" for current box
      "off"  for no X
      a hostname or IP for arbitrary location
EOF
        return 1;
    fi

    if [[ -z $2 ]]
    then
	SCREEN=0.0
    else
	SCREEN=$2
    fi

    HOST=$1

    case $HOST in
       "back")
	    if [ -z $REMOTEHOST ]
            then
		echo REMOTEHOST not set...
		return 1
            fi
    	    export DISPLAY=$REMOTEHOST:0.0
    	    ;;
       "here")
    	    export DISPLAY=:0.0
    	    ;;
       "off")
    	    export DISPLAY=
    	    ;;
       *)
    	    export DISPLAY=$HOST\:$SCREEN
    	    ;;
    esac

    return 0;
}

function xrsh()
{
   xhost $1 > /dev/null
   xterm -T rsh.$1 -n rsh.$1 -e rsh $* > /dev/null
}

function xssh()
{
   xterm -T ssh.$1 -n ssh.$1 -e ssh -Y $* > /dev/null
}

function xterme()
{
   declare title=$@
   xterm  -T "$title" -n "$title" -e "$@"
}



function xtitle()
{
    case $TERM in
        [xk]term*|cygwin)
           echo -ne "\033]0;${1}\007"
           ;;
	*)
	   echo "sorry, don't know how to set the title for $TERM..."
           ;;
    esac
}

function deathto()
{
    declare sigspec=

    if [[ ${1} =~ -.* ]]
    then
        sigspec=${1}
        shift
    fi
    if (( ! ${#} ))
    then
        printf 'deathto: usage: deathto [-sigspec] regex...\n'
        return 1
    fi
    #          UID   PID  PPID  C STIME TTY          TIME CMD
    #          root    1     0  0 Apr05 ?        00:01:47 /sbin/init
    #          root    2     0  0 Apr05 ?        00:00:00 [kthreadd]
    #          root    3     2  0 Apr05 ?        00:00:04 [ksoftirqd/0]
    #          root    5     2  0 Apr05 ?        00:00:00 [kworker/0:0H]
    declare -a regex=( "${@}" )
    declare uid pid cmd _
    while read uid   pid     _  _ _     _         _       cmd
    do
        declare i=
        for ((i=0; i < ${#regex[*]}; i++))
        do
            if [[ ${cmd} =~ ${regex[i]} ]]
            then
                kill ${sigspec} "${pid}"
            fi
        done
    done < <(ps -wwef)
}

function path_gc()
{
    local IFS=:
    local -a paths=(${PATH})
    unset IFS
    PATH=

    for ((i = 0; i < ${#paths[*]}; i++))
    do
        local path=${paths[${i}]}
        if [[ -n ${path} ]]
        then
            PATH="${PATH}:${path}"
        fi
    done
    # toss first colon
    PATH=${PATH:1}
}

function make_exec()
{
    declare cmd=

    while (( ${#@} ))
    do
        cmd=${cmd}${1}','
        shift
    done
    cmd=${cmd/%,}  # whack last comma
    cmd=${cmd/,/ } # first comma -> space
    make -s -f - <<EOF
all:; @#
\$(info \$(call if,,,\$\$(${cmd})))
EOF
}

function make_repl()
{
    make "${@}" -s -f <(printf %s '
_getline=$(shell printf "\# " >&0 && head -1 | sed -e "s/!/!1/g;s/$$/!n/")
_eatline=$(if $1,$(eval $(subst !1,!,$(subst !n,,$1)))1)
_repl=$(if $(call _eatline,$(call _getline)),$(call $0))

$(call _repl)

all: ; @#

')
}

function tee_log()
{
    declare out=${*}
    out=${out//\//%}
    if [[ ${out} == .* ]]
    then
        out=${out/./_}
    fi

    "$@" 2>&1 | tee -- "${out// /_}.log"
}

function find_grep()
{
    declare findargs=( )

    while [[ ${1} != "--" ]]
    do
        findargs=( "${findargs[@]}" "${1}" )
        shift
    done
    shift

    (( ${#findargs[*]} )) || findargs=( . -type f )

    find "${findargs[@]}" -print0 | xargs -0 grep "${@}"

}

function updirs()
{
    declare lookinfer=${1}
    declare dir=${2:-$(pwd)}

    while [[ ! -e ${dir}/${lookinfer} && -n ${dir} ]]
    do
        dir=${dir%/*}
    done

    if [[ ! -e ${dir}/${lookinfer} ]]
    then
        printf 'error: updirs: %s not found\n' "${lookinfer}" >&2
        return 1
    fi
    printf '%s\n' "${dir}/${lookinfer}"
}

function docker_reset() {
  declare images=( $(docker images -q) )
  declare jobs=( $(docker ps -q) )
  while [[ -n $images || -n $jobs ]] || !docker container prune -f ; do
    [[ -z $jobs ]] || docker kill "${jobs[@]}"
    [[ -z $images ]] || docker rmi -f "${images[@]}"
    images=( $(docker images -q) )
    jobs=( $(docker ps -q) )
  done
}
